#!/usr/bin/env bash

# Collect information from the host to be post-processed by the analyzer

#################################################################################################
# ipmctl collector 
#################################################################################################

function ipmctl_collector() {
  echo "Running IPMCTL Collector"

  if [ ${OPT_VERBOSITY} -ge 1 ]; then
    debug_msg "Using ${IPMCTL}"
  fi

  IFS="" #Change the delimiter to prevent Bash separating elements by spaces
  ipmctl_args=(
    "version" 
    "show -topology" 
    "show -a -topology" 
    "show -socket" 
    "show -a -socket" 
    "show -dimm" 
    "show -a -dimm" 
    "show -memoryresources" 
    "show -goal" 
    "show -a -goal" 
    "show -system"
    "show -system NFIT"
    "show -system PCAT"
    "show -system PMTT"
    "show -system -capabilities"
    "show -a -system -capabilities"
    "show -region"
    "show -a -region"
    "show -firmware"
    "show -a -firmware"
    "show -preferences"
    "show -cel"
    "show -performance"
    "show -sensor"
    "show -error Media"
    "show -a -error Media"
    "show -error Thermal"
    "show -a -error Thermal"
    "show -pcd"
    "show -pcd Config"
    "show -pcd LSA"
    "show -cel"
  )
  
  for arg in ${ipmctl_args[@]}; do
    # Provide progress to user
    # TODO: Display a percentage progress bar. For now. dots will do.
    echo -n "."
    # Create output files
    # Replace spaces in the command and agrs to be used as the output file name
    OFNAME="ipmctl ${arg}"
    OFNAME="${OFNAME// /_}" # Use the Bash string replace feature rather than calling sed or awk
    CMD_OUTPUT_FILE="${OUTPUT_PATH}/${OFNAME}"
    CMD_ERR_OUTPUT_FILE="${OUTPUT_PATH}/${OFNAME}.err"
    # Run the ipmctl command with arguments
    # Redirect errors to the error file
    if eval "${IPMCTL} ${arg}" 2> ${CMD_ERR_OUTPUT_FILE} 1> ${CMD_OUTPUT_FILE} ; then
      if [ ${OPT_VERBOSITY} -ge 1 ]; then
        debug_msg "${IPMCTL} ${arg} Command ${green}succeeded${normal}"
      fi
    else
      if [ ${OPT_VERBOSITY} -ge 1 ]; then
        debug_msg "${IPMCTL} ${arg} Command ${red}failed${normal}"
      fi
    fi
  done
  echo ""
}

#################################################################################################
# ndctl collector
#################################################################################################

function ndctl_collector() {
  echo "Running NDCTL Collector"

  if [ ${OPT_VERBOSITY} -ge 1 ]; then
    debug_msg "Using ${NDCTL}"
  fi 

  IFS="" #Change the delimiter to prevent Bash separating elements by spaces
  ndctl_args=(
    "version"
    "list -vvv"
    "list --dimms --firmware --health --media-errors"
    "list --dimms --firmware --health --media-errors --idle"
    "list --regions"
    "list --regions --idle"
    "list --namespaces --device-dax"
    "list --namespaces --device-dax --idle"
  )

  for arg in ${ndctl_args[@]}; do
    # Provide progress to user
    # TODO: Display a percentage progress bar. For now. dots will do.
    echo -n "."
    # Create output files
    # Replace spaces in the command and agrs to be used as the output file name
    OFNAME="ndctl ${arg}"
    OFNAME="${OFNAME// /_}" # Use the Bash string replace feature rather than calling sed or awk
    CMD_OUTPUT_FILE="${OUTPUT_PATH}/${OFNAME}"
    CMD_ERR_OUTPUT_FILE="${OUTPUT_PATH}/${OFNAME}.err"
    # Run the ndctl command with arguments
    # Redirect errors to the error file
    if eval "${NDCTL} ${arg}" 2> ${CMD_ERR_OUTPUT_FILE} 1> ${CMD_OUTPUT_FILE} ; then
      if [ ${OPT_VERBOSITY} -ge 1 ]; then
        debug_msg "${NDCTL} ${arg} Command ${green}succeeded${normal}"
      fi
    else
      if [ ${OPT_VERBOSITY} -ge 1 ]; then
        debug_msg "${NDCTL} ${arg} Command ${red}failed${normal}"
      fi
    fi
  done
  echo ""
}

#################################################################################################
# cxl collector 
#################################################################################################

function cxl_collector() {
  echo "Running CXL Collector"

  if [ ${OPT_VERBOSITY} -ge 1 ]; then
    debug_msg "Using ${CXLCLI}"
  fi

  IFS="" #Change the delimiter to prevent Bash separating elements by spaces
  cxl_args=(
    "version"
    "list --memdevs --health"
    "list --memdevs --health --idle"
  )

  for arg in ${cxl_args[@]}; do
    # Provide progress to user
    # TODO: Display a percentage progress bar. For now. dots will do.
    echo -n "."
    # Create output files
    # Replace spaces in the command and agrs to be used as the output file name
    OFNAME="cxl ${arg}"
    OFNAME="${OFNAME// /_}" # Use the Bash string replace feature rather than calling sed or awk
    CMD_OUTPUT_FILE="${OUTPUT_PATH}/${OFNAME}"
    CMD_ERR_OUTPUT_FILE="${OUTPUT_PATH}/${OFNAME}.err"
    # Run the cxl command with arguments
    # Redirect errors to the error file
    if eval "${CXLCLI} ${arg}" 2> ${CMD_ERR_OUTPUT_FILE} 1> ${CMD_OUTPUT_FILE} ; then
      if [ ${OPT_VERBOSITY} -ge 1 ]; then
        debug_msg "${CXLCLI} ${arg} Command ${green}succeeded${normal}"
      fi
    else
      if [ ${OPT_VERBOSITY} -ge 1 ]; then
        debug_msg "${CXLCLI} ${arg} Command ${red}failed${normal}"
      fi
    fi
  done
  echo ""
}

#################################################################################################
# General 
#################################################################################################

function collect_files() {
  echo "Collecting files"

  IFS="" #Change the delimiter to prevent Bash separating elements by spaces
  files_to_collect=(
    "/var/log/messages"
  )

  for file in ${files_to_collect[@]}; do
    # Provide progress to user
    # TODO: Display a percentage progress bar. For now. dots will do.
    echo -n "."
    if [ ${OPT_VERBOSITY} -ge 2 ]; then
      debug_msg "Collecting ${file}"
    fi
    if [[ -f "${file}" ]] ; then # Copy files that exist
      if ${CP} ${file} ${OUTPUT_PATH} 2> ${OUTPUT_PATH}/cp.err ; then 
        if [ ${OPT_VERBOSITY} -ge 1 ]; then
          debug_msg "${CP} ${file} ${OUTPUT_PATH} Command ${green}succeeded${normal}"
        fi
      else
        if [ ${OPT_VERBOSITY} -ge 1 ]; then
          debug_msg "${CP} ${file} ${OUTPUT_PATH} Command ${red}failed${normal}"
        fi
      fi
    fi
  done
  echo ""
}

function collect_cmds() {
  echo "Collecting command outputs"

  IFS="" #Change the delimiter to prevent Bash separating elements by spaces
  commands_to_collect=(
    "dmidecode"
    "lscpu"
  )

  for cmd in ${commands_to_collect[@]}; do
    # Provide progress to user
    # TODO: Display a percentage progress bar. For now. dots will do.
    echo -n "."
    if [ ${OPT_VERBOSITY} -ge 2 ]; then
      debug_msg "Collecting ${cmd}"
    fi
    # Create output files
    # Replace spaces in the command and agrs to be used as the output file name
    OFNAME="${cmd}"
    OFNAME="${OFNAME// /_}" # Use the Bash string replace feature rather than calling sed or awk
    CMD_OUTPUT_FILE="${OUTPUT_PATH}/${OFNAME}"
    CMD_ERR_OUTPUT_FILE="${OUTPUT_PATH}/${OFNAME}.err"
    # Run the command with arguments
    # Redirect errors to the error file
    if eval "${cmd}" 2> ${CMD_ERR_OUTPUT_FILE} 1> ${CMD_OUTPUT_FILE} ; then
      if [ ${OPT_VERBOSITY} -ge 1 ]; then
        debug_msg "${cmd} Command ${green}succeeded${normal}"
      fi
    else
      if [ ${OPT_VERBOSITY} -ge 1 ]; then
        debug_msg "${cmd} Command ${red}failed${normal}"
      fi
    fi
  done
  echo ""
}

#################################################################################################
# Helper Functions
#################################################################################################

function display_collector_header() {
  echo "======================================================================="
  echo "Starting data collector"
  echo "======================================================================="
}

function display_collector_end() {
  echo "======================================================================="
  echo "Data collector completed"
  echo "======================================================================="
}

# Remove zero length files from the output directory
function remove_empty_files() {
  if [ ${OPT_VERBOSITY} -ge 2 ]; then
    debug_msg "Removing empty files from ${OUTPUT_PATH}"
    find ${OUTPUT_PATH} -type f -empty -delete -print
  else
    find ${OUTPUT_PATH} -type f -empty -delete
  fi
}

# Cleanup routine
function collector_cleanup() {
  unset IFS
  remove_empty_files
}

#################################################################################################
# Main 
#################################################################################################

# Run the individual collectors
display_collector_header
ipmctl_collector
ndctl_collector
cxl_collector
#general_collector
collect_files
collect_cmds
collector_cleanup
display_collector_end
